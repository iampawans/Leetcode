{"id":1068720967,"lang":"cpp","lang_name":"C++","time":"2Â months","timestamp":1696609266,"status":10,"status_display":"Accepted","runtime":"17 ms","url":"/submissions/detail/1068720967/","is_pending":"Not Pending","title":"Convert Sorted List to Binary Search Tree","memory":"28.5 MB","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n/*\n    void insertBefore(ListNode** head, int val){\n        cout << \"insertBefore val : \" << val << endl;\n        ListNode* newNode= new ListNode();\n        newNode->val = val;\n        newNode->next = *head;\n        *head = newNode;\n    }\n\n    void insertAfter(ListNode** head, int val){\n        cout << \"insertAfter val : \" << val << endl;\n        ListNode* newNode= new ListNode();\n        newNode->val = val;\n        newNode->next = NULL;\n\n        ListNode* tmp = *head;\n        if(*head == NULL){\n            *head = newNode;\n            return;\n        }\n\n        while(tmp->next != NULL){\n            tmp =tmp->next;\n        }\n\n        tmp->next = newNode;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head == NULL)\n            return NULL;\n        \n        ListNode* tmp = head;\n        ListNode* tmp1 = head;\n        TreeNode* tree = new TreeNode();\n        //Get Number of elements\n        int count =0;\n        while(tmp != NULL){\n            count++;\n            tmp = tmp->next;\n        }\n\n        ListNode* left = NULL;\n        ListNode* right = NULL;\n\n        int mid = count/2 +1;\n        cout << \"count : \" << count << \" mid : \" << mid << endl;\n        while(tmp1 != NULL){\n            if(count > mid){\n                cout << \"Before insertBefore\" << endl;\n                insertBefore(&left, tmp1->val);\n            }\n            else if(count == mid){\n                cout << \"count == mid -> tmp1->val : \" << tmp1->val << endl;\n                tree->val = tmp1->val;\n            }\n            else{\n                cout << \"Before insertAfter\" << endl;\n                insertBefore(&right, tmp1->val);\n            }\n            tmp1 = tmp1->next;\n            count--;\n        }\n        ListNode* l = left;\n        while(l != NULL){\n            cout << \"l->val : \" << l->val << endl;\n            l = l->next;\n        }\n        ListNode* r = right;\n        while(r != NULL){\n            cout << \"r->val : \" << r->val << endl;\n            r = r->next;\n        }\n        tree->left = sortedListToBST(left);\n        tree->right = sortedListToBST(right);\n        return tree;\n    }\n    */\n    TreeNode* sortedListToBST(ListNode *head){\n    \treturn semiSortedListToBST( head, NULL );\n    }\n\n    TreeNode* semiSortedListToBST(ListNode* head, ListNode* tail){\n        if(head == tail){\n            return NULL;\n        }\n\n        //find middle\n        ListNode* tmp = head;\n        ListNode* mid=head;\n        while(tmp != tail && tmp->next != tail){\n            mid = mid->next;\n            tmp = tmp->next->next;\n        }\n\n        //create Tree\n        TreeNode* tree = new TreeNode();\n        tree->val = mid->val;\n        tree->left = semiSortedListToBST(head, mid);\n        tree->right = semiSortedListToBST(mid->next, tail);\n        return tree;\n    }\n\n};","compare_result":"11111111111111111111111111111111","title_slug":"convert-sorted-list-to-binary-search-tree","has_notes":false,"flag_type":1}