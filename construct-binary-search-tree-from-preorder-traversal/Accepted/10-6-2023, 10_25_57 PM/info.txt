{"id":1068747051,"lang":"cpp","lang_name":"C++","time":"2Â months","timestamp":1696611357,"status":10,"status_display":"Accepted","runtime":"6 ms","url":"/submissions/detail/1068747051/","is_pending":"Not Pending","title":"Construct Binary Search Tree from Preorder Traversal","memory":"17.4 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\n        //preorder = [8,5,1,7,10,12]\n        //inorder = [1,5,7,8,10,12]\n        vector<int> inorder = preorder;\n        std::sort(inorder.begin(), inorder.end());\n        return subBstFromPreorder( preorder, inorder);        \n    }\n\n    TreeNode* subBstFromPreorder(vector<int>& preorder, vector<int>& inorder){\n        if(preorder.size() == 0 || inorder.size() == 0){\n            return NULL;\n        }\n        \n        TreeNode* tree = new TreeNode();\n        int root = preorder[0];\n        bool found = false;\n        vector<int> left_inorder, right_inorder;\n        for(int i= 0; i< inorder.size(); i++){\n            if(!found && inorder[i] != root){\n                left_inorder.push_back(inorder[i]);\n            }\n            else if(inorder[i] == root){\n                found = true;\n                tree->val = root;\n                continue;\n            }\n            else if(found){\n                right_inorder.push_back(inorder[i]);\n            }\n        }\n\n        vector<int> preorder_left, preorder_right;\n        preorder_left.insert(preorder_left.end(), preorder.begin()+1, preorder.end()-right_inorder.size());\n        preorder_right.insert(preorder_right.end(), preorder.begin()+left_inorder.size()+1, preorder.end());\n\n        tree->left = subBstFromPreorder(preorder_left, left_inorder);\n        tree->right = subBstFromPreorder(preorder_right, right_inorder);\n        return tree;\n    }    \n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-search-tree-from-preorder-traversal","has_notes":false,"flag_type":1}