{"id":1063018413,"lang":"cpp","lang_name":"C++","time":"2Â months","timestamp":1696076609,"status":10,"status_display":"Accepted","runtime":"64 ms","url":"/submissions/detail/1063018413/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"119.2 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        //preorder = [3,9,20,15,7]  Root->Left->Right\n        //inorder = [9,3,15,20,7]  Left->Root->Right\n        TreeNode* tree = new TreeNode();\n        if (preorder.size() == 0 || inorder.size()== 0){\n            return NULL;\n        }\n\n        tree->val = preorder[0];\n        vector<int> inorder_left, inorder_right;\n        bool root= false;\n\n\n        // inroder\n        for(int i : inorder){\n            // fill inorder_left\n            if(!root && i != preorder[0]){\n                inorder_left.push_back(i);\n            }\n            else if(i == preorder[0]){\n                root = true;\n                continue;\n            }\n\n            // fill inorder_right\n            if(root){\n                inorder_right.push_back(i);\n            }\n        }\n\n        // preoredr\n        vector<int> preorder_left, preorder_right;\n        preorder_left.insert(preorder_left.end(), preorder.begin()+1, preorder.end()-inorder_right.size());        \n        preorder_right.insert(preorder_right.end(), preorder.begin()+inorder_left.size()+1, preorder.end());\n\n\n        //Fill tree->left\n        tree->left = buildTree(preorder_left, inorder_left);\n        //Fill tree->right\n        tree->right = buildTree(preorder_right, inorder_right);\n        return tree;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal","has_notes":false,"flag_type":1}