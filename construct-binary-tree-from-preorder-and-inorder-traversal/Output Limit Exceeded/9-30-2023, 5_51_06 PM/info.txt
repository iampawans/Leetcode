{"id":1063017116,"lang":"cpp","lang_name":"C++","time":"2Â months","timestamp":1696076466,"status":13,"status_display":"Output Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1063017116/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        //preorder = [3,9,20,15,7]  Root->Left->Right\n        //inorder = [9,3,15,20,7]  Left->Root->Right\n        TreeNode* tree = new TreeNode();\n        if (preorder.size() == 0 || inorder.size()== 0){\n            return NULL;\n        }\n        /*if (preorder.size() == 1 || inorder.size()== 1){\n            tree->val = preorder[0];\n            return tree;\n        }*/\n        tree->val = preorder[0];\n        vector<int> inorder_left, inorder_right;\n        bool root= false;\n\n        cout << \"preorder[0] : \" << preorder[0] << endl;\n        // inroder\n        for(int i : inorder){\n            // fill inorder_left\n            if(!root && i != preorder[0]){\n                inorder_left.push_back(i);\n            }\n            else if(i == preorder[0]){\n                root = true;\n                continue;\n            }\n\n            // fill inorder_right\n            if(root){\n                inorder_right.push_back(i);\n            }\n        }\n        for(int i : inorder_left){\n            cout << \"inorder_left : \" << i << endl;\n        }\n        for(int i : inorder_right){\n            cout << \"inorder_right : \" << i << endl;\n        }\n        // preoredr\n        vector<int> preorder_left, preorder_right;\n        preorder_left.insert(preorder_left.end(), preorder.begin()+1, preorder.end()-inorder_right.size());\n        for(int i : preorder_left){\n            cout << \"preorder_left : \" << i << endl;\n        }        \n        preorder_right.insert(preorder_right.end(), preorder.begin()+inorder_left.size()+1, preorder.end());\n        for(int i : preorder_right){\n            cout << \"preorder_right : \" << i << endl;\n        }\n\n        cout << \"Fill tree->left\" << endl;\n        tree->left = buildTree(preorder_left, inorder_left);\n        cout << \"Fill tree->right\" << endl;\n        tree->right = buildTree(preorder_right, inorder_right);\n        return tree;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal","has_notes":false,"flag_type":1}