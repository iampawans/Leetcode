{"id":1063207866,"lang":"cpp","lang_name":"C++","time":"2Â months","timestamp":1696088582,"status":10,"status_display":"Accepted","runtime":"72 ms","url":"/submissions/detail/1063207866/","is_pending":"Not Pending","title":"Construct Binary Tree from Inorder and Postorder Traversal","memory":"118.6 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        //inorder = [9,3,15,20,7]  Left->Root->Right\n        //postorder = [9,15,7,20,3]  Left->Right->Root\n        if(postorder.size() == 0 || inorder.size()==0){\n            return NULL;\n        }\n        \n        TreeNode* tree = new TreeNode();\n        vector<int> inorder_left, inorder_right;\n        bool root = false;\n        \n        tree->val = postorder[postorder.size()-1];\n\n        //inorder\n        for(int i : inorder){\n            //inorder_left\n            if(!root && (i != postorder[postorder.size()-1])){\n                inorder_left.push_back(i);\n            }\n            else if(i == postorder[postorder.size()-1]){\n                root = true;\n                continue;\n            }\n            else if(root){\n                inorder_right.push_back(i);\n            }\n        }\n\n        //postorder\n        vector<int> postorder_left, postorder_right;\n        postorder_left.insert(postorder_left.end(), postorder.begin(), postorder.end()-inorder_right.size()-1);\n        postorder_right.insert(postorder_right.end(), postorder.begin()+inorder_left.size(), postorder.end()-1);\n\n        tree->left = buildTree(inorder_left, postorder_left);\n        tree->right = buildTree(inorder_right, postorder_right);\n\n        return tree;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-inorder-and-postorder-traversal","has_notes":false,"flag_type":1}